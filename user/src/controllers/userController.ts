import { publishToQueue } from "../config/rabbitmq.js";
import tryCatch from "../config/trycatch.js";
import { redisClient } from "../index.js";
import { UserModel } from "../model/User.js";
import { generateToken } from "../config/generatetoken.js";
import type { IAuthenticatedRqst } from "../middleware/isAuth.js";
import type { Request, Response } from "express";
export const loginUser = tryCatch(async (req, res) => {
  /*

1.The function you pass to tryCatch is your handler — it's an anonymous async function defined right there inside the tryCatch call.
2.So, in this case, you create the handler “inline” as an anonymous function and immediately pass it to tryCatch.
3.tryCatch receives this handler function and returns a new wrapped function that adds error handling.
4.Then, you export this wrapped function as loginUser.


Why this is normal and valid:
1.You don’t have to define your handler separately first; it’s perfectly fine to define it inline as an anonymous function.
2.The key idea is: tryCatch always receives a handler function (named or anonymous) as its input and returns a wrapped function.

Summary:
1.We are passing a handler, just anonymously and inline.
2.tryCatch wraps that handler with error catching.
3.The returned wrapped function becomes your exported loginUser.
4.This pattern keeps your code clean and error-safe without duplicating try-catch everywhere.

Alternatively we can do this as below:-
async function loginUserHandler(req, res, next) {
  // your logic here
}
export const loginUser = tryCatch(loginUserHandler);

*/
  const { email } = req.body;
  const rateLimitKey = `otp:rateLimit:${email}`;
  const rateLimit = await redisClient.get(rateLimitKey);
  if (rateLimit) {
    res.status(429).json({
      message: "TOO MANY RQST FOR OTP ,PLEASE WAIT FOR A WHILE",
    });
    return;
  }
  const otp = Math.floor(100000 + Math.random() * 900000).toString();
  /* 
  1.To make otp of random number b/w 100000 to 999999 we multiply random number with 900000 if we multiply with any other smaller number the range of otp will become narrow and may not contain all digits b/w 0 to 9.
  2.We add 100000 bcz there might be cases when random number generated by math.random() is too small that even after multyplying it with 900000,there will be only one significant figure so tackle that random case we add 100000 which ensure that even if the number is too small the number become significant to upto 6 digits.

  E.g 
  1. random number =>0.0000587
  multiplying it with 900000
  2. random number =5.87 
  its not a 6 digit number
  3. add 100000 to this random number
  its become =100005.87 
  */
  const otpKey = `otp:${email}`;
  await redisClient.set(otpKey, otp, {
    EX: 300,
  });

  await redisClient.set(rateLimitKey, "true", {
    EX: 60,
  });
  const message = {
    to: email,
    subject: "YOUR OTP CODE IS HERE  ",
    body: `👍YOUR OTP IS ${otp} IS READY AND WILL EXPIRE IN 1 MINUTE ,IF OTP EXPIRED PLEASE CLICK ON RESEND OTP BUTTON TO GET NEW OTP `,
  };
  await publishToQueue("send-otp", message);
  res.status(200).json({
    message: "otp sent to your mail 👍",
  });
});

export const verifyUser = tryCatch(async (req, res) => {
  const { email, otp: enteredOtp } = req.body;
  // otp: enteredOtp: It gets the value of the otp property from req.body and assigns it to a new variable called enteredOtp (the property is renamed when destructuring) instead of the default variable name otp.
  if (!email || !enteredOtp) {
    res.status(400).json({
      message: "Email and Otp is required",
    });
    return;
  }
  const otpKey = `otp:${email}`;
  const storedOtp = await redisClient.get(otpKey);
  // stored Otp is the otp stored in our redis
  if (!storedOtp || storedOtp !== enteredOtp) {
    res.status(400).json({
      message: "Invalid or Expired Otp ",
    });
    return;
    // if we don't put return here then ,even if the otp is wrong then also the user will be created and  the otp will get deleted in redis
  }
  // deleting the stored-otp from the redis
  await redisClient.del(otpKey);

  let user = await UserModel.findOne({ email });
  if (!user) {
    const name = email.slice(0, 8);
    user = await UserModel.create({ name, email });
  }

  const generatedtoken = generateToken(user);
  user.token = generatedtoken;

  await user.save();
  res.status(200).json({
    message: "USER VERIFIED",
    user,
    generatedtoken,
  });
});

export const myProfile = tryCatch(
  async (req: IAuthenticatedRqst, res: Response) => {
    const user = await UserModel.findById(req.user?._id);
    // console.log(user);

    res.status(200).json({
      message: "User retrieved successfully HURRAH !👌",
      user: user,
    });
  }
);

export const updateName = tryCatch(
  async (req: IAuthenticatedRqst, res: Response) => {
    const user = await UserModel.findById(req.user?._id);
    if (!user) {
      res.status(401).json({
        message: "Please login first to update the name",
      });
      return;
    }
    user.name = req.body.name;
    const updatedName = user.name;
    await user.save();
    const updatedToken = generateToken(user);
    user.token = updatedToken;
    await user.save();
    res.status(200).json({
      message: "Username Updated Successfully",
      user,
      updatedToken,
    });
  }

  /* UPDATED VERSION OF ABOVE CODE WITH MORE ERROR HANDLING AND PRECAUTION 
export const updateName = tryCatch(
  async (req: IAuthenticatedRqst, res: Response) => {
    const userId = req.user?._id;
    if (!userId) {
      return res.status(401).json({
        message: "Please login first to update the name",
      });
    }

    if (!req.body.name || typeof req.body.name !== "string") {
      return res.status(400).json({
        message: "Invalid or missing name in request body",
      });
    }

    const updatedUser = await UserModel.findByIdAndUpdate(
      userId,
      { name: req.body.name },
      { new: true, runValidators: true }
    );

    if (!updatedUser) {
      return res.status(404).json({
        message: "User not found",
      });
    }

    const updatedToken = generateToken(updatedUser);

    res.json({
      message: "Username Updated Successfully",
      user: updatedUser,
      updatedToken,
    });
  }
);
*/
);

export const getAllUsers = tryCatch(async (req: Request, res: Response) => {
  const users = await UserModel.find();

  res.status(200).json({
    message: "Users fetched Successfully 🤣",
    users,
  });
});
export const getAUser = tryCatch(async (req: Request, res: Response) => {
  const user = await UserModel.findById(req.params?.id);
  res.status(200).json({
    message: "User find Successfully 😁",
    user,
  });
});
